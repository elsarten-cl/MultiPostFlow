
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for readable, secure, and maintainable rules.

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Validates that the requesting user's UID matches the document's owner ID.
     * This is the primary function for enforcing the user-ownership model.
     * @param userId The UID of the user to check for ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    function isAdmin() {
      // Check for the specific admin email OR if the user's document has the 'admin' role.
      // This get() is safe for rules on single documents, but not for list queries.
      let isHardcodedAdmin = request.auth.token.email == 'agencia@elsartenpro.com';
      let userHasAdminRole = isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
      return isHardcodedAdmin || userHasAdminRole;
    }

    function isApprovedUser(userId) {
      return isSignedIn() && get(/databases/$(database)/documents/users/$(userId)).data.status == 'approved';
    }
    
    /**
     * Validates the structure and integrity of a new user document upon creation.
     */
    function isValidNewUser(userId) {
        let data = request.resource.data;
        let isAdminAttempt = data.role == 'admin';
        let isFirstAdmin = data.email == 'agencia@elsartenpro.com';

        // All new users must be created with 'pending' status and 'user' role
        return isOwner(userId) && 
               data.id == userId &&
               data.email == request.auth.token.email &&
               data.name == (request.auth.token.name || request.auth.token.email.split('@')[0]) &&
               data.status == 'pending' &&
               data.type == 'revista' && // Default type
               (!isAdminAttempt || (isAdminAttempt && isFirstAdmin)) && // Prevent self-proclaiming admin
               (data.role == 'user' || (data.role == 'admin' && isFirstAdmin));
    }

    /**
     * Validates updates to a user document.
     */
    function isValidUserUpdate(userId) {
      let data = request.resource.data;
      let existingData = resource.data;

      // Regular users can only update their own name.
      let isUserUpdatingName = isOwner(userId) &&
                               data.keys().hasOnly(['name']) &&
                               data.name != existingData.name;
      
      // Admins can update 'role', 'type', and 'status'. They cannot change other fields.
      let isAdminUpdatingPermissions = isAdmin() &&
                                       data.id == existingData.id &&
                                       data.email == existingData.email &&
                                       data.createdAt == existingData.createdAt &&
                                       (data.role != existingData.role || data.type != existingData.type || data.status != existingData.status);

      return isUserUpdatingName || isAdminUpdatingPermissions;
    }

    match /users/{userId} {
      allow get: if isOwner(userId) || isAdmin();
      // Only admins can list users. The rule is simplified to check the email directly
      // to avoid a complex query that Firestore rules cannot handle for 'list'.
      allow list: if request.auth.token.email == 'agencia@elsartenpro.com';
      allow create: if isValidNewUser(userId);
      allow update: if isValidUserUpdate(userId);
      // Only admins can delete users, but not themselves.
      allow delete: if isAdmin() && request.auth.uid != userId;

      match /drafts/{draftId} {
        allow read, write: if isSignedIn() && isApprovedUser(userId) && isOwner(userId);
      }

      match /postStates/{postStateId} {
        allow read, write: if isSignedIn() && isApprovedUser(userId) && isOwner(userId);
      }

      match /automationLogs/{automationLogId} {
        allow read, write: if isSignedIn() && isApprovedUser(userId) && isOwner(userId);
      }
    }
  }
}
